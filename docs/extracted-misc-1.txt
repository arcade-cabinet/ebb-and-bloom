// Globals
let world, player, critters = [], resources = [];
let pollution = 0, behavior = { harmony: 0.3, conquest: 0.3, frolick: 0.4 }; // Yuka profiles
let tileSize = 16, gridSize = 64;
let noise = new SimplexNoise(); // Procedural seed
let db; // IndexedDB

// ECS Schemas (BitECS)
const Position = bitecs.defineComponent({ x: 'f32', y: 'f32' });
const Velocity = bitecs.defineComponent({ vx: 'f32', vy: 'f32' });
const Biome = bitecs.defineComponent({ type: 'u8' }); // 0=forest,1=river,2=plain,...
const Resource = bitecs.defineComponent({ type: 'u8', affinity: 'u32' }); // Bitflags: heat=1,flow=2,bind=4
const Trait = bitecs.defineComponent({ chainsaw: 'u8', flipper: 'u8', /*...*/ });
const Behavior = bitecs.defineComponent({ harmony: 'f32', conquest: 'f32', frolick: 'f32' });
const Pollution = bitecs.defineComponent({ echo: 'u8' });

// Queries
const tileQuery = bitecs.defineQuery([Position, Biome, Pollution]);
const playerQuery = bitecs.defineQuery([Position, Velocity, Trait]);
const critterQuery = bitecs.defineQuery([Position, Velocity]); // Yuka-wrapped

// Init
function init() {
    world = new bitecs.World();
    setupDB();
    generateWorld();
    spawnPlayer(); // After creator
    spawnCritters(10);
    updateLoop();
}

// DB Setup (Saves)
function setupDB() {
    const req = indexedDB.open('EvoForge', 1);
    req.onupgradeneeded = e => e.target.result.createObjectStore('saves', { keyPath: 'id' });
    req.onsuccess = e => db = e.target.result;
}
function saveGame() {
    const state = { pollution, behavior, entities: serializeWorld() /* BitECS snapshot */ };
    const tx = db.transaction('saves', 'readwrite');
    tx.objectStore('saves').put({ id: 'current', ...state });
}
function loadGame() {
    const tx = db.transaction('saves', 'readonly');
    const req = tx.objectStore('saves').get('current');
    req.onsuccess = e => {
        if (e.target.result) {
            pollution = e.target.result.pollution;
            // Deserialize: recreate entities
            init(); // Regen base, overlay save
        }
    };
}

// World Gen
function generateWorld() {
    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            const id = bitecs.addEntity(world, [Position, Biome, Pollution]);
            Position.x[id] = x * tileSize;
            Position.y[id] = y * tileSize;
            const n = noise.noise2D(x * 0.1, y * 0.1);
            Biome.type[id] = n > 0.5 ? 0 : (n > 0 ? 1 : 2); // Forest/River/Plain
            Pollution.echo[id] = 5; // Baseline scars
            // TODO: Adjacency snaps - query neighbors post-gen
        }
    }
    snapCheck(); // Initial magnetic compat
}

// Snapping System
function snapCheck() {
    const tiles = tileQuery(world);
    for (let i = 0; i < tiles.length; i++) {
        const id = tiles[i];
        // Query adj (up/down/left/right - O(1) via spatial hash? Expand later)
        const adj = getAdjacents(id); // Stub: return nearby Resource entities
        for (let a of adj) {
            if (hasResource(id) && hasResource(a)) {
                const snapType = combineResources(Resource.type[id], Resource.type[a]);
                if (snapType) {
                    // Spawn new entity
                    const newId = bitecs.addEntity(world, [Position, Resource]);
                    Position.x[newId] = (Position.x[id] + Position.x[a]) / 2;
                    Position.y[newId] = (Position.y[id] + Position.y[a]) / 2;
                    Resource.type[newId] = snapType;
                    resources.push(newId);
                    pollution += 1; // Echo
                    updateBehavior('conquest', 0.1); // Profile nudge
                }
            }
        }
    }
}
function combineResources(t1, t2) {
    // Procedural perms: Bitmask affinity
    const aff1 = Resource.affinity[/*from t1*/], aff2 = Resource.affinity[/*t2*/];
    if ((aff1 & 1) && (aff2 & 2)) return 3; // Ore(heat) + Water(flow) = Alloy
    // Expand: +power(4) = Circuit, etc. Noise-seed variants
    return 0;
}
function getAdjacents(id) {
    // Spatial query stub - for MVP, brute force <64^2
    return tileQuery(world).filter(tid => dist(id, tid) < tileSize * 1.5);
}

// Player Spawn & Creator
let playerTraits = {};
function showCreator() {
    document.getElementById('creator').style.display = 'block';
    const edCtx = document.getElementById('editor').getContext('2d');
    // Draw grid: 12x12 for 8x8 parts (pad)
    edCtx.fillStyle = '#000'; edCtx.fillRect(0,0,96,96);
    // TODO: Drag-drop parts from atlas (load PNG)
}
function trait(name, cost) {
    const pts = parseInt(document.getElementById('points').textContent);
    if (pts >= cost) {
        playerTraits[name] = (playerTraits[name] || 0) + 1;
        document.getElementById('points').textContent = pts - cost;
    }
}
function startGame() {
    document.getElementById('creator').style.display = 'none';
    spawnPlayer();
}
function spawnPlayer() {
    const id = bitecs.addEntity(world, [Position, Velocity, Trait, Behavior]);
    Position.x[id] = 32 * tileSize; Position.y[id] = 32 * tileSize;
    Velocity.vx[id] = 0; Velocity.vy[id] = 0;
    // Apply traits
    Trait.chainsaw[id] = playerTraits.chainsaw || 0;
    Trait.flipper[id] = playerTraits.flipper || 0;
    player = id;
    // Yuka Vehicle wrapper
    const vehicle = new Yuka.Vehicle();
    vehicle.position.set(Position.x[id], Position.y[id], 0);
    vehicle.setRenderComponent({ /* Canvas draw func */ });
    Yuka.EntityManager.getInstance().add(vehicle);
}

// Input & Update
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);
function updatePlayer() {
    const id = player;
    if (keys['ArrowLeft'] || keys['a']) Velocity.vx[id] -= 0.1;
    // ... other dirs, clamp
    // Terraform: Mouse click → change Biome.type
    // Harvest: Proximity to Resource → add to inv, trait mods (chainsaw *2 wood)
}
function updateCritters() {
    critterQuery(world).forEach(id => {
        // Yuka steering: Flock if harmony high
        const vehicle = /* get Yuka ent */ ;
        const seek = new Yuka.SeekBehavior(playerPos);
        if (behavior.harmony > 0.6) vehicle.steering.add(seek); // Ally follow
        else if (behavior.conquest > 0.6) vehicle.steering.add(new Yuka.FleeBehavior(playerPos)); // Evade
    });
    // Cycle evo: Every 5min, mutate based on profile/pollution
    if (Date.now() % 300000 < 16) evolveEcosystem();
}
function evolveEcosystem() {
    // Yuka decision: Weighted random
    const roll = noise.noise2D(Date.now(), pollution);
    if (roll > 0.7) { /* Shock if pollution >70 */ mutateWorld(); }
    else { /* Gentle: New variant sprites */ }
}
function mutateWorld() { // Shock
    gridSize += 8; // Expand
    // Reseed border tiles, cull 20% critters, tint pollution
    pollution = Math.max(0, pollution - 50); // Clear post-shock
}
function updateBehavior(axis, delta) {
    behavior[axis] = Math.min(1, behavior[axis] + delta);
    // Normalize sum=1
    const total = Object.values(behavior).reduce((a,b)=>a+b,0);
    for (let k in behavior) behavior[k] /= total;
    document.getElementById('status').innerHTML = `Pollution: ${pollution} | Style: ${Object.entries(behavior).sort((a,b)=>b[1]-a[1])[0][0]}`;
}

// Render
function render() {
    const ctx = document.getElementById('world').getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,1024,1024);
    // Tiles
    tileQuery(world).forEach(id => {
        const x = Position.x[id], y = Position.y[id];
        let color = Biome.type[id] === 0 ? '#0a0' : (Biome.type[id] === 1 ? '#00a' : '#aaa');
        if (Pollution.echo[id] > 20) color = '#800'; // Tint
        ctx.fillStyle = color; ctx.fillRect(x, y, tileSize, tileSize);
        // Draw resources/snaps as overlays
    });
    // Player: Draw pixel parts based on traits (atlas slice)
    if (player) {
        const px = Position.x[player], py = Position.y[player];
        ctx.fillStyle = '#f00'; ctx.fillRect(px, py, 8, 8); // Stub sprite
        // TODO: Modular draw: head + arms(chainsaw=spiky pixels)
    }
    // Critters: 8x8 sprites, animated
    critterQuery(world).forEach(id => {
        ctx.fillStyle = '#00f'; ctx.fillRect(Position.x[id], Position.y[id], 8, 8);
    });
}

// Loop
function updateLoop() {
    updatePlayer();
    updateCritters();
    snapCheck(); // On changes
    document.getElementById('poll').textContent = pollution;
    render();
    requestAnimationFrame(updateLoop);
}

// Utils
function dist(id1, id2) {
    const dx = Position.x[id1] - Position.x[id2], dy = Position.y[id1] - Position.y[id2];
    return Math.sqrt(dx*dx + dy*dy);
}
function hasResource(id) { return Resource.type[id] > 0; } // Etc.
function serializeWorld() { /* BitECS arrays to JSON */ return {}; }

// Spawn Critters Stub
function spawnCritters(n) {
    for (let i = 0; i < n; i++) {
        const id = bitecs.addEntity(world, [Position, Velocity]);
        Position.x[id] = Math.random() * 1024;
        Position.y[id] = Math.random() * 1024;
        // Yuka Vehicle + FlockBehavior
        const v = new Yuka.Vehicle();
        v.position.set(Position.x[id], Position.y[id], 0);
        Yuka.EntityManager.getInstance().add(v);
        critters.push(v);
    }
}

// Boot
init();
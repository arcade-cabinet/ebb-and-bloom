function attuneNexusFusion(clutchIds, catalystTrait) {
  const attuned = clutchIds.every(id => shardAffMatch(id, clutchIds[0])); // >70%
  if (!attuned) return { error: 'Mismatch' };
  const nexusId = addEntity(world, [Nexus]);
  Nexus.clutchAff[nexusId] = averageAff(clutchIds); // Shared bits
  Nexus.catalyst[nexusId] = catalystTrait;
  // Yuka echo sim
  const echoFlock = spawnEchoProxies(clutchIds.length); // Temp critters
  echoFlock.yukaBehavior = new Yuka.FlockBehavior(nexusCorePos); // Converge
  setTimeout(() => resolveFusion(nexusId), fusionCycle);
}

function resolveFusion(nexusId) {
  const nexus = getNexus(nexusId);
  const roll = noise.noise2D(nexusId, behavior.conquest);
  const taintAvg = averageTaint(clutchIds);
  let foldType = roll > (0.3 + (1 - taintAvg/100) * 0.4) ? 0 : (roll > 0.1 ? 1 : 2); // Skew
  if (behavior.harmony > 0.6) foldType = Math.min(foldType, 1); // No full shatter
  if (foldType === 0) {
    // Flourish: Fold grid
    expandChunk(nexus.pos, nexus.clutchAff, 20); // +Size with aff biomes
    useGame.setState({ evoPoints: get().evoPoints + clutchSize * 2, shardVault: [] }); // Clear
  } else if (foldType === 1) {
    // Fracture: Mini
    expandChunk(nexus.pos, nexus.clutchAff, 10);
    pollution += 10;
    warpRandomTile(nexus.pos); // Echo
  } else {
    // Shatter: Abyss
    spawnAbyss(nexus.pos, 5); // Void chunk
    pollution += 30;
    if (pollution > 70) mutateWorld();
    playerAura.debuff('fractured', 3); // Cycles
    spawnAbyssNexus(nexus.pos); // Seed
  }
  // Clean clutch
  clutchIds.forEach(id => removeEntity(id));
  removeEntity(nexusId);
}
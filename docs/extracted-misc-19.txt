function spawnVengeanceShard(pos, grudgeGenes) {
  const id = addEntity(world, [Position, Shard]);
  Position.x[id] = pos.x; Position.y[id] = pos.y;
  Shard.aff[id] = grudgeGenes | wildBit; // Procedural
  Shard.taint[id] = Math.floor(Math.random() * 100); // 0-99%
  useGame.setState({ shardVault: [...get().shardVault, { id: id.toString(), aff: Shard.aff[id], taint: Shard.taint[id] }] });
}

function harvestShard(shardId) {
  const shard = getShard(shardId);
  const roll = noise.noise2D(shardId, playerTraits.aff);
  if (roll > (0.2 + (shard.taint / 100))) { // Success skew
    // Unfurl stub: If adj snap, fuse
    const adj = getAdjacents(shard.pos);
    if (adj.length) {
      const newAff = Shard.aff[shardId] | adj[0].aff;
      spawnSnap(newAff, shard.pos); // Chain start
      pollution += shard.taint / 20; // Risk
    }
    removeEntity(shardId);
    useGame.setState((state) => ({ shardVault: state.shardVault.filter(s => s.id !== shardId.toString()) }));
  } else {
    // Bleed
    pollution += 5;
    spawnWisp(shard.pos); // Mini-rival
  }
}

function fuseShards(shardIds) {
  if (shardIds.length < 3) return;
  const avgAff = shardIds.reduce((sum, id) => sum + Shard.aff[id], 0) / shardIds.length;
  const avgTaint = Math.min(100, shardIds.reduce((sum, id) => sum + Shard.taint[id], 0) / shardIds.length);
  const relicId = addEntity(world, [Relic]); // New type
  Relic.aff[relicId] = avgAff;
  Relic.taint[relicId] = avgTaint * (behavior.conquest > 0.6 ? 1 : 0.5); // Skew
  // Evo cost/payoff
  useGame.setState({ evoPoints: get().evoPoints - 1 + (shardIds.length * 1.5) });
  shardIds.forEach(id => removeEntity(id));
}
// Snippet 1 - Context: - **Gesture Thrum**: Swipe surge? Audio trail (whoosh Doppler shift) ramps haptic from light (start) to heavy (impact), easing with reverb tail. Pinch siphon: Suck-in gurgle = pulling vibration (decelerating pulses), bloom release = explosive swell (haptic crescendo + audio bloom chord). ### POC Tease (Capacitor/Web Audio) Quick sync hook—paste into a morph event:

// Flipper to Tidal Scar Sync
const audio = new AudioContext(); // Sine swell + noise gurgle
const osc = audio.createOscillator(); osc.frequency.setValueAtTime(200, audio.currentTime); // Hum
const noiseGain = audio.createGain(); noiseGain.gain.setValueAtTime(0.2, audio.currentTime + 0.25); // Twist
osc.connect(audio.destination).start();

// Haptic Sync: Audio envelope drives pulses
const envelope = (time) => 0.5 + 0.5 * Math.sin(time * 0.2); // Perlin-ish curve
setInterval(() => {
  const intensity = envelope(audio.currentTime) * 0.3; // 0-0.3g
  Haptics.vibrate({ duration: 100 * intensity }); // Capacitor tie
}, 100); // 10Hz sync to low-end

// ---

// Snippet 2 - Context: Hell yeah, burr surge POC— that heat-power hybrid's gritty zaps deserve a thrum that *itches* your palm, metallic scrape layering into electric forks with haptic spikes syncing the crackle. Building on the flipper tease, this gen's a chainsaw-to-burr morph: Rusty grind swells to spark-burr buzz, pitch-modded by Perlin for chaotic edge, haptics escalating from grind rumble to jolt bursts (0.4-0.6g, forked for dual motors). ### POC Sketch (Web Audio + Capacitor Haptics) Runtime hook for morph event—~3KB, loops the surge ache. (Devs: Tie to Phaser tween for visual sync.)

// Burr Surge Morph Sync POC
const audioCtx = new AudioContext();
const morph = () => {
  // Base: Chainsaw grind (square osc + noise scrape)
  const osc1 = audioCtx.createOscillator(); osc1.type = 'square'; osc1.frequency.setValueAtTime(150, audioCtx.currentTime); // Low growl
  const noise = audioCtx.createBufferSource(); // Scrape noise
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.3; // Filtered white noise
  noise.buffer = buffer;
  const filter = audioCtx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 300; // Metallic bite
  const gain1 = audioCtx.createGain(); gain1.gain.setValueAtTime(0.4, audioCtx.currentTime); gain1.gain.exponentialRampToValueAtTime(0.15, audioCtx.currentTime + 0.6);
  osc1.connect(gain1).connect(audioCtx.destination);
  noise.connect(filter).connect(gain1); noise.start();
  osc1.start();

  // Twist: Power zap (FM mod + spark crackle, Perlin jitter)
  const carrier = audioCtx.createOscillator(); carrier.frequency.setValueAtTime(400, audioCtx.currentTime + 0.3);
  const modulator = audioCtx.createOscillator(); modulator.frequency.setValueAtTime(80, audioCtx.currentTime + 0.3); modulator.connect(carrier.frequency); // FM burr
  const perlinJitter = (t) => 0.8 + 0.4 * Math.sin(t * 0.15 + Math.random() * Math.PI); // Chaotic edge
  carrier.frequency.setTargetAtTime(400 + perlinJitter(0) * 200, audioCtx.currentTime + 0.3, 0.1); // Jitter zaps
  const gain2 = audioCtx.createGain(); gain2.gain.setValueAtTime(0.25, audioCtx.currentTime + 0.3); gain2.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 1);
  carrier.connect(gain2).connect(audioCtx.destination);
  modulator.start(audioCtx.currentTime + 0.3); carrier.start(audioCtx.currentTime + 0.3);

  // Haptic Sync: Grind rumble to zap forks
  const envelope = (time) => 0.6 + 0.4 * Math.sin(time * 0.3); // Perlin curve for burr
  setInterval(() => {
    const intensity = envelope(audio.currentTime) * 0.5; // 0-0.5g
    Haptics.vibrate({ duration: 150 * intensity }); // Escalate pulses
    if (audio.currentTime > 0.3) Haptics.impact({ style: 'medium' }); // Zap fork at twist
  }, 150); // 6.67Hz sync to FM low-end
};

// Trigger on morph
morph(); // Visual tie: Burr trail sparks with audio peaks

// ---

// Snippet 3 - Context: Hell yeah, visual shader morph sync— that's the evo *glow*, where a trait unfurl (flipper to tidal scar) doesn't just pixel-shift; it *pulses* with a shader veil, sub-pixel haze warping in time with the audio swell and haptic throb. In Ebb & Bloom, it's WebGL post-FX: GLSL fragment shader sampling the morph tween (0-1 progress from trait dilute), blending base/hybrid textures with noise-modded distortion (Perlin for chaotic burrs, sine for tidal flows). Sync to audio envelope (gain peaks drive shader intensity), haptics ramp on distortion peaks—feels like the world's vein *breathing* your gesture. ### POC: Tidal Scar Morph Shader (GLSL Fragment) Runtime in Phaser (post-render pass)—tween morphProg from 0 (flipper base) to 1 (scar hybrid), audio gain mods the warp. ~500 lines total, mobile 60FPS lean.

precision mediump float;
uniform sampler2D baseTex; // Flipper sprite
uniform sampler2D hybridTex; // Tidal scar overlay
uniform float morphProg; // 0-1 tween from evo event
uniform float audioEnvelope; // 0-1 from Web Audio gain (sync swell)
uniform vec2 resolution;
varying vec2 vUv;
uniform float time; // For Perlin warp

// Simple Perlin noise (tidal twist)
float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}
float fbm(vec2 p) { // Fractal for ebb flow
    float n = 0.0;
    for (int i = 0; i < 3; i++) {
        n += noise(p * (1.0 + float(i))) / pow(2.0, float(i+1));
        p *= 2.0;
    }
    return n;
}

void main() {
    vec2 uv = vUv;
    // Warp UV with audio-sync Perlin (tidal distort)
    vec2 warp = vec2(fbm(uv * 3.0 + time * 0.5 + audioEnvelope * 2.0), fbm(uv * 3.0 * 0.5 + time * 0.3));
    uv += warp * 0.05 * morphProg; // Subtle ebb on prog

    // Lerp textures with haze bloom
    vec4 base = texture2D(baseTex, uv);
    vec4 hybrid = texture2D(hybridTex, uv + vec2(0.01 * morphProg, 0.0)); // Offset for scar fin
    vec4 morphColor = mix(base, hybrid, smoothstep(0.0, 1.0, morphProg));

    // Audio-driven glow (envelope amps emerald rift)
    float glow = audioEnvelope * (1.0 - morphProg) * fbm(uv * 10.0); // Inverse for fade-in
    morphColor.rgb += vec3(0.0, glow * 0.8, glow * 0.6); // Emerald haze

    // FXAA tease: Simple edge soften
    vec2 invRes = 1.0 / resolution;
    vec3 n = texture2D(baseTex, uv + vec2(0.0, -invRes.y)).rgb;
    vec3 s = texture2D(baseTex, uv + vec2(0.0, invRes.y)).rgb;
    vec3 w = texture2D(baseTex, uv + vec2(-invRes.x, 0.0)).rgb;
    vec3 e = texture2D(baseTex, uv + vec2(invRes.x, 0.0)).rgb;
    morphColor.rgb = mix(morphColor.rgb, (n + s + w + e) / 4.0, 0.2 * morphProg); // Smooth on twist

    gl_FragColor = morphColor;
}

// ---

// Snippet 4 - Context: Runtime in Phaser (post-render pass)—tween morphProg from 0 (flipper base) to 1 (scar hybrid), audio gain mods the warp. ~500 lines total, mobile 60FPS lean. ### Sync Tease (Phaser Tie-In) Hook to morph event—audio envelope feeds uniform, haptics pulse on warp peaks.

// Phaser post-FX pass
const shader = this.add.postFX('morph-shader', { morphProg: 0, audioEnvelope: 0 });
morphTween.to({ morphProg: 1 }, 1000); // Trait dilute
audio.onaudioprocess = (e) => shader.audioEnvelope = gainNode.gain.value; // Sync swell
// Haptic: Warp intensity >0.5? Haptics.impact({ style: 'light' });

// ---

// Snippet 5 - Context: #### 3. **Web Audio Morph Expansion: Burr Surge Sync (Evo Haptic-Audio)**    - **Why Expand?**: Stub's basic; this fulls it with FM layers for burr zap, syncing to haptic forks + shader intensity (via uniform). Procedural jitter via Perlin for chaotic edge.    - **Full Code**: `src/audio/evoMorph.ts` (~220 lines).

// src/audio/evoMorph.ts
import { Capacitor } from '@capacitor/core';
import { Haptics } from '@capacitor/haptics';

class EvoMorphAudio {
  private ctx: AudioContext;
  private gain: GainNode;
  private isPlaying = false;

  constructor() {
    this.ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
    this.gain = this.ctx.createGain();
    this.gain.connect(this.ctx.destination);
  }

  // Burr Surge Morph: Grind to zap (heat + power)
  async burrSurge(duration = 1, intensity = 0.5) {
    if (this.isPlaying) this.stop();
    this.isPlaying = true;

    // Base grind: Square osc + noise scrape
    const osc1 = this.ctx.createOscillator();
    osc1.type = 'square';
    osc1.frequency.setValueAtTime(150, this.ctx.currentTime);
    const noiseBuffer = this.createNoiseBuffer(0.5);
    const noise = this.ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 300;
    const gain1 = this.ctx.createGain();
    gain1.gain.setValueAtTime(0.4 * intensity, this.ctx.currentTime);
    gain1.gain.exponentialRampToValueAtTime(0.15 * intensity, this.ctx.currentTime + 0.6);
    osc1.connect(gain1);
    noise.connect(filter).connect(gain1);
    gain1.connect(this.gain);
    osc1.start();
    noise.start();

    // Power zap twist: FM carrier + modulator
    const carrier = this.ctx.createOscillator();
    carrier.frequency.setValueAtTime(400, this.ctx.currentTime + 0.3);
    const modulator = this.ctx.createOscillator();
    modulator.frequency.setValueAtTime(80, this.ctx.currentTime + 0.3);
    modulator.connect(carrier.frequency); // FM burr
    const perlinJitter = (t: number) => 0.8 + 0.4 * Math.sin(t * 0.15 + Math.random() * Math.PI);
    carrier.frequency.setTargetAtTime(400 + perlinJitter(0) * 200, this.ctx.currentTime + 0.3, 0.1);
    const gain2 = this.ctx.createGain();
    gain2.gain.setValueAtTime(0.25 * intensity, this.ctx.currentTime + 0.3);
    gain2.gain.exponentialRampToValueAtTime(0.05 * intensity, this.ctx.currentTime + 1);
    carrier.connect(gain2).connect(this.gain);
    modulator.start(this.ctx.currentTime + 0.3);
    carrier.start(this.ctx.currentTime + 0.3);

    // Haptic sync: Grind rumble to zap forks
    const hapticInterval = setInterval(() => {
      if (!this.isPlaying) return;
      const envelope = (t: number) => 0.6 + 0.4 * Math.sin(t * 0.3 + Math.random() * Math.PI);
      const env = envelope(this.ctx.currentTime) * 0.5 * intensity; // 0-0.5g
      if (env > 0.3) {
        Haptics.impact({ style: 'medium' }); // Zap fork
      } else {
        Haptics.vibrate({ duration: 150 * env }); // Rumble build
      }
    }, 150); // 6.67Hz low-end sync

    setTimeout(() => this.stop(hapticInterval), duration * 1000);
  }

  private createNoiseBuffer(duration: number): AudioBuffer {
    const bufferSize = this.ctx.sampleRate * duration;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
    return buffer;
  }

  private stop(interval?: NodeJS.Timeout) {
    this.isPlaying = false;
    if (interval) clearInterval(interval);
    this.gain.gain.setValueAtTime(0, this.ctx.currentTime);
  }

  // Tie to shader: Envelope feeds uniform
  getEnvelope(): number {
    return this.gain.gain.value;
  }
}

export const useEvoMorphAudio = () => new EvoMorphAudio();
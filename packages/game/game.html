<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ebb & Bloom - Open World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Work Sans', -apple-system, sans-serif;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #ffffff;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            pointer-events: none;
        }
        
        #compass {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff4444;
            font-weight: bold;
            pointer-events: none;
        }
        
        #location-info {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #ffffff;
            padding: 12px;
            font-family: 'Work Sans', sans-serif;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            pointer-events: none;
            text-align: right;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-family: 'Playfair Display', serif;
        }
    </style>
</head>
<body>
    <div id="loading">Generating world...</div>
    <div id="hud" style="display: none;">
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Biome: <span id="biome">Plains</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>
    <div id="compass" style="display: none;">N</div>
    <div id="location-info" style="display: none;">
        <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;" id="settlement-name">Unknown</div>
        <div style="font-size: 12px; color: #aaa;" id="settlement-type">Wilderness</div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { EntityManager, Vehicle, Time } from 'yuka';
        import { ChunkManager } from './src/world/ChunkManager.ts';
        import { CreatureSpawner } from './src/world/CreatureSpawner.ts';
        import { FirstPersonControls } from './src/player/FirstPersonControls.ts';
        import { WaterSystem } from './src/world/WaterSystem.ts';
        import { DialogueSystem } from './src/world/DialogueSystem.ts';
        import { DialogueUI } from './src/world/DialogueUI.ts';
        import { ActionButtons } from './src/player/ActionButtons.ts';
        import { Minimap } from './src/ui/Minimap.ts';
        
        console.log('üéÆ Ebb & Bloom - Starting...');
        
        // Get seed from URL or use default
        const urlParams = new URLSearchParams(window.location.search);
        const seed = urlParams.get('seed') || 'v1-green-valley-breeze';
        console.log('üå± Seed:', seed);
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 400, 1200); // See much further
        
        // Camera (first-person)
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 5, 0);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Lighting (BRIGHTER - Daggerfall was bright and clear)
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.camera.left = -200;
        sun.shadow.camera.right = 200;
        sun.shadow.camera.top = 200;
        sun.shadow.camera.bottom = -200;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);
        
        const ambient = new THREE.AmbientLight(0x606060, 0.8); // Brighter ambient
        scene.add(ambient);
        
        // Yuka time system (proper delta calculation)
        const time = new Time();
        
        // Yuka entity manager for all entities (player + creatures)
        const entityManager = new EntityManager();
        
        // Gravity settings (Daggerfall-like)
        const gravity = -9.8; // m/s^2 (realistic, not harsh)
        const playerHeight = 1.8; // Player eye height (DFU uses ~1.8m)
        const controllerHeight = 2.0; // CharacterController equivalent
        const jumpVelocity = 5.0; // Jump strength
        let verticalVelocity = 0;
        let isGrounded = false;
        let isAttacking = false;
        let attackCooldown = 0;
        
        // Chunk streaming (Daggerfall approach) - pass entityManager for NPCs
        const chunkManager = new ChunkManager(scene, seed, entityManager);
        chunkManager.update(0, 0); // Load initial chunks FIRST
        
        // CRITICAL: Spawn player IN A SETTLEMENT (like Daggerfall)
        // Get nearest settlement from ChunkManager
        const startSettlement = chunkManager.getNearestSettlement(0, 0);
        
        let spawnX, spawnZ;
        if (startSettlement) {
            // Spawn in settlement center
            spawnX = startSettlement.position.x;
            spawnZ = startSettlement.position.z;
            console.log(`üèòÔ∏è Starting in ${startSettlement.name} (${startSettlement.type})`);
        } else {
            // Fallback to offset spawn
            spawnX = 50;
            spawnZ = 50;
            console.log('‚ö†Ô∏è No settlement found, spawning in wilderness');
        }
        
        const terrainHeight = chunkManager.getTerrainHeight(spawnX, spawnZ);
        const spawnY = terrainHeight + playerHeight;
        
        console.log(`üéÆ SPAWN: (${spawnX.toFixed(0)}, ${spawnZ.toFixed(0)}), terrain: ${terrainHeight.toFixed(1)}m, Y: ${spawnY.toFixed(1)}m`);
        
        // Create player entity (Yuka Vehicle) AT TERRAIN HEIGHT
        const player = new Vehicle();
        player.position.set(spawnX, spawnY, spawnZ); // Spawn ON ground, not arbitrary height
        player.maxSpeed = 10;
        player.name = 'player';
        entityManager.add(player);
        
        // Connect camera to player (Yuka pattern)
        function syncCamera(entity, renderComponent) {
          renderComponent.position.setFromMatrixPosition(entity.worldMatrix);
        }
        player.setRenderComponent(camera, syncCamera);
        
        // Player controls (Yuka pattern) - pass camera for pitch control
        const controls = new FirstPersonControls(player, camera);
        
        // Set initial camera angle - LEVEL like Daggerfall
        controls.setRotation(0, 0); // Yaw 0 (north), Pitch 0 (level horizon)
        
        // Minimap (Daggerfall-style)
        const minimap = new Minimap();
        if (startSettlement) {
            minimap.setSettlement(startSettlement);
        }
        
        // Action buttons (mobile)
        const actionButtons = new ActionButtons({
            onJump: () => {
                if (isGrounded) {
                    verticalVelocity = jumpVelocity;
                    isGrounded = false;
                    console.log('ü¶ò Jump!');
                }
            },
            onAttack: () => {
                if (attackCooldown <= 0) {
                    isAttacking = true;
                    attackCooldown = 0.5; // 500ms cooldown
                    console.log('‚öîÔ∏è Attack!');
                    
                    // Attack animation/effect (simple flash for now)
                    setTimeout(() => {
                        isAttacking = false;
                    }, 200);
                }
            },
            onUse: () => {
                console.log('‚úã Use/Interact');
                // TODO: Raycast to find interactable objects
            },
            onSprint: (active) => {
                player.maxSpeed = active ? 20 : 10;
                console.log(active ? 'üèÉ Sprint!' : 'üö∂ Walk');
            }
        });
        
        // Water system
        const waterSystem = new WaterSystem(scene, 0); // Sea level at y=0
        
        // Creature spawning
        const creatureSpawner = new CreatureSpawner(scene, entityManager, seed);
        
        // Spawn creatures in initial chunks
        for (let x = -3; x <= 3; x++) {
            for (let z = -3; z <= 3; z++) {
                creatureSpawner.spawnInChunk(x, z);
            }
        }
        
        console.log('‚úÖ Terrain system ready');
        console.log(`‚úÖ Spawned ${creatureSpawner.getCreatureCount()} creatures`);
        console.log('‚úÖ Player entity created');
        
        // Dialogue system
        const dialogueUI = new DialogueUI((option) => {
            // When player selects an option
            const response = dialogueSystem.selectOption(option);
            dialogueUI.updateText(response);
            
            // If it was "Goodbye", hide UI
            if (!dialogueSystem.isDialogueActive()) {
                dialogueUI.hide();
            }
        });
        
        const dialogueSystem = new DialogueSystem(scene, camera, seed, {
            onOpen: (state) => {
                dialogueUI.show(state);
                // Release pointer lock when dialogue opens
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            },
            onClose: () => {
                dialogueUI.hide();
            }
        });
        
        // Keyboard actions (Space = jump, E = use)
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && isGrounded && document.pointerLockElement) {
                verticalVelocity = jumpVelocity;
                isGrounded = false;
                console.log('ü¶ò Jump!');
                event.preventDefault();
            }
            
            if (event.code === 'KeyE' && document.pointerLockElement) {
                console.log('‚úã Use/Interact');
                // TODO: Raycast for interactables
                event.preventDefault();
            }
        });
        
        // Click handling - attack OR interact with NPC
        document.addEventListener('click', (event) => {
            // If dialogue is open, ignore (handled by UI buttons)
            if (dialogueUI.isVisible()) {
                return;
            }
            
            // If pointer locked, this is an attack
            if (document.pointerLockElement) {
                if (attackCooldown <= 0) {
                    isAttacking = true;
                    attackCooldown = 0.5;
                    console.log('‚öîÔ∏è Attack!');
                    setTimeout(() => { isAttacking = false; }, 200);
                }
                return;
            }
            
            // If pointer not locked, try to interact with NPC
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Get all NPC meshes
            const npcMeshes = chunkManager.getAllNPCMeshes();
            const hitMesh = dialogueSystem.raycastNPC(x, y, npcMeshes);
            
            if (hitMesh) {
                // Find NPC data
                const npcData = chunkManager.getNPCByMesh(hitMesh);
                if (npcData) {
                    dialogueSystem.startDialogue(npcData, chunkManager.getGameTime());
                }
            } else {
                // No NPC hit - lock pointer for FPS controls
                controls.connect();
            }
        });
        
        // Game loop (proper Yuka pattern with Time)
        let frames = 0;
        let fpsTime = 0;
        
        function update() {
            const delta = time.update().getDelta();
            
            // FPS counter
            frames++;
            fpsTime += delta;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = frames.toString();
                frames = 0;
                fpsTime = 0;
            }
            
            // Update controls (handles WASD input)
            controls.update(delta);
            
            // Update attack cooldown
            if (attackCooldown > 0) {
                attackCooldown -= delta;
            }
            
            // Update water animation
            waterSystem.update(delta);
            
            // Update NPCs (schedules)
            chunkManager.updateNPCs(delta);
            
            // GRAVITY & COLLISION (DFU CharacterController style)
            const terrainHeight = chunkManager.getTerrainHeight(player.position.x, player.position.z);
            const eyeHeightTarget = terrainHeight + playerHeight; // Camera at eye height
            
            // Check if grounded (like DFU's CollisionFlags.Below)
            isGrounded = Math.abs(player.position.y - eyeHeightTarget) < 0.5;
            
            if (isGrounded) {
                // On ground - snap to eye height above terrain
                player.position.y = eyeHeightTarget;
                verticalVelocity = 0;
            } else {
                // In air - apply gravity
                verticalVelocity += gravity * delta;
                player.position.y += verticalVelocity * delta;
                
                // Don't fall through ground
                if (player.position.y < eyeHeightTarget) {
                    player.position.y = eyeHeightTarget;
                    verticalVelocity = 0;
                    isGrounded = true;
                }
            }
            
            // Update all entities (player + creatures)
            entityManager.update(delta);
            
            // Update chunks based on player position
            chunkManager.update(player.position.x, player.position.z);
            
            // Update minimap
            minimap.update(player.position.x, player.position.z, controls.movementX || 0);
            
            // Update HUD
            document.getElementById('pos').textContent = 
                `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
            
            const gameHour = Math.floor(chunkManager.getGameTime());
            const ampm = gameHour >= 12 ? 'PM' : 'AM';
            const displayHour = gameHour % 12 || 12;
            
            document.getElementById('biome').textContent = 
                `Time: ${displayHour}:00 ${ampm} | Settlements: ${chunkManager.getSettlementCount()} | NPCs: ${chunkManager.getNPCCount()} | Trees: ${chunkManager.getVegetationCount()} | Creatures: ${creatureSpawner.getCreatureCount()}`;
            
            // Render
            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }
        
        // Start
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('compass').style.display = 'flex';
            document.getElementById('location-info').style.display = 'block';
            
            // Set location info
            if (startSettlement) {
                document.getElementById('settlement-name').textContent = startSettlement.name;
                const typeText = startSettlement.type.charAt(0).toUpperCase() + startSettlement.type.slice(1);
                document.getElementById('settlement-type').textContent = `${typeText} ‚Ä¢ Population: ${startSettlement.population}`;
            }
            
            console.log('‚úÖ Game ready - Click to capture mouse, WASD to move');
            update();
        }, 1000);
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>


# GitHub Copilot Workspace Instructions

You are working on **Ebb & Bloom**, a mobile-first procedural pixel-world evolution game built with Phaser 3, BitECS, Vue 3, Ionic, and Capacitor.

## Project Overview

**Ebb & Bloom** is a touch-first mobile game where players explore a procedurally generated world, evolve traits through resource manipulation, and witness the world react to their playstyle. The game emphasizes:

- **Procedural World Generation**: Perlin noise-based biomes (water, grass, sand, rocks)
- **Entity Component System**: BitECS for performant game logic
- **Reactive State Management**: Zustand for UI/game state synchronization
- **Mobile-First UX**: Haptic feedback, gesture controls, 60 FPS target
- **Behavior-Driven Narrative**: World reacts to player style (Harmony, Conquest, Frolick)

## Architecture Principles

### Core Systems (BitECS)

1. **ECS Architecture**
   - All game logic in ECS systems
   - Components are data-only (no logic)
   - Systems operate on component queries
   - Single world instance (`src/ecs/world.ts`)

2. **State Management**
   - Zustand store (`src/stores/gameStore.ts`) for reactive UI
   - ECS is source of truth
   - Store syncs FROM ECS, never writes directly

3. **Rendering**
   - Phaser 3 for rendering ONLY
   - No game logic in Phaser scenes
   - Sprite pooling for performance
   - Viewport culling for large worlds

### Game Systems Implemented

1. **Trait System** (`src/ecs/components/traits.ts`)
   - 10 modular traits (FlipperFeet, ChainshawHands, etc.)
   - Synergy combinations (e.g., Burr-tide from Flipper + Chainshaw)
   - Evolution points system

2. **Snapping System** (`src/ecs/systems/SnappingSystem.ts`)
   - Affinity-based resource combination
   - Bit-flag overlap checks
   - Procedural haiku generation

3. **Pollution & Shock System** (`src/ecs/systems/PollutionSystem.ts`)
   - Tracks Echo and Tainted pollution
   - Triggers world shocks (Whisper, Tempest, Collapse)
   - Playstyle influences shock effects

4. **Behavior Profiling** (`src/ecs/systems/BehaviorSystem.ts`)
   - Tracks player actions in rolling window
   - Classifies playstyle (Harmony, Conquest, Frolick)
   - Modifies world reactions

5. **Pack System** (`src/ecs/systems/PackSystem.ts`)
   - Critter social dynamics
   - Pack formation, loyalty, schism
   - Trait inheritance from player

6. **Haptic System** (`src/systems/HapticSystem.ts`)
   - Playstyle-aware haptic patterns
   - Complex sequences (tension, heartbeat, crescendo)
   - Capacitor Haptics integration

7. **Gesture System** (`src/systems/GestureSystem.ts`)
   - Enhanced touch controls (swipe, pinch, hold, tap, drag, rotate)
   - Gesture-to-action mapping
   - Mobile-first interaction

### Code Standards

#### File Organization
```
src/
├── ecs/
│   ├── world.ts              # ECS world instance
│   ├── components/           # Component definitions
│   ├── entities/             # Entity factories
│   └── systems/              # Game logic systems
├── stores/
│   └── gameStore.ts          # Zustand reactive state
├── systems/                  # Non-ECS systems (haptics, gestures)
├── game/
│   ├── GameScene.js          # Phaser rendering
│   └── core/                 # World generation
└── test/                     # Vitest tests
```

#### Naming Conventions
- **Components**: PascalCase, noun (e.g., `Position`, `Velocity`)
- **Systems**: PascalCase with "System" suffix (e.g., `MovementSystem`)
- **ECS Queries**: camelCase with "Query" suffix (e.g., `movementQuery`)
- **Stores**: camelCase with "Store" suffix (e.g., `gameStore`)

#### Testing Requirements
- All systems MUST have tests (`src/test/*.test.ts`)
- Use Vitest with happy-dom environment
- Mock Phaser and Capacitor in tests
- Aim for 80%+ coverage on ECS systems

#### Performance Targets
- **Mobile 60 FPS**: Required for smooth gameplay
- **Sprite Pooling**: Reuse sprites, never destroy/create
- **Viewport Culling**: Only render visible tiles
- **Component Queries**: Cache queries, don't recreate

### Design Document Reference

All game mechanics are documented in `docs/`:
- `00-vision.md` - Core game philosophy
- `02-traits.md` - Trait system design (RESOLVED)
- `03-crafting.md` - Crafting/snapping mechanics
- `04-pollution.md` - Pollution and shock system
- `05-critters.md` - Pack dynamics
- `06-controls.md` - Mobile UX
- `08-roadmap.md` - Development stages

**When implementing features, always check docs/ first for existing design.**

### CI/CD Pipeline

1. **Test Workflow** (`.github/workflows/build-android.yml`)
   - Runs on every push/PR
   - Executes test suite (57 tests)
   - Builds web assets
   - Validates TypeScript

2. **Build Android APK**
   - Initializes Capacitor Android if needed
   - Builds debug/release APKs
   - Uploads artifacts (30-90 day retention)

3. **Code Quality** (`.github/workflows/quality.yml`)
   - TypeScript validation
   - Test coverage
   - Documentation checks
   - ECS architecture validation

4. **Release** (`.github/workflows/release.yml`)
   - Triggered by version tags (v*)
   - Builds APKs
   - Creates GitHub Release
   - Auto-generated release notes

### Development Workflow

1. **Before Making Changes**
   - Read relevant memory bank files (`memory-bank/`)
   - Check design docs (`docs/`)
   - Review existing tests

2. **When Adding Features**
   - Create ECS components/systems
   - Add tests FIRST (TDD)
   - Update Zustand store if UI reactive state needed
   - Update Phaser scene ONLY for rendering
   - Update memory bank (`activeContext.md`, `progress.md`)

3. **When Fixing Bugs**
   - Add failing test that reproduces bug
   - Fix bug
   - Ensure test passes
   - Document in progress.md

4. **Before Committing**
   - Run `pnpm test` (all must pass)
   - Check for linter errors
   - Use semantic commit messages (feat:, fix:, chore:, docs:)

### Memory Bank Usage

**ALWAYS read memory bank files at start of task:**
- `projectbrief.md` - Project scope and requirements
- `productContext.md` - Game design goals
- `systemPatterns.md` - Architecture patterns
- `techContext.md` - Tech stack and setup
- `activeContext.md` - Current work focus
- `progress.md` - Status and known issues

**Update memory bank when:**
- Implementing significant features
- Discovering new patterns
- Changing architecture
- User requests "update memory bank"

### Common Pitfalls

❌ **Don't put game logic in Phaser scenes** - Use ECS systems
❌ **Don't write directly to Zustand store from game logic** - Store syncs FROM ECS
❌ **Don't create/destroy sprites in render loop** - Use sprite pooling
❌ **Don't skip tests** - All systems need tests
❌ **Don't ignore docs/** - Design is already planned
❌ **Don't commit without updating memory bank** - Documentation must stay current

### Key Technologies

- **Phaser 3.87+**: Rendering engine
- **BitECS 0.3.40**: Entity Component System
- **Zustand 5.0+**: State management
- **Vitest 2.1+**: Testing framework
- **Vue 3.5+**: UI framework
- **Ionic 8.7+**: Mobile UI components
- **Capacitor 6.1+**: Native mobile wrapper
- **Yuka 0.7+**: AI/pathfinding (planned)
- **pnpm 9.x**: Package manager

### Repository Context

- **Branch**: `copilot/add-perlin-chunk-world`
- **Stage**: POC (Stage 1)
- **Status**: 8 major systems implemented, 57/57 tests passing
- **Next**: Complete remaining design docs, test on device
- **CI/CD**: Fully automated builds and releases

---

**For detailed architecture, always refer to `memory-bank/systemPatterns.md`**  
**For current status, always check `memory-bank/progress.md` and `memory-bank/activeContext.md`**

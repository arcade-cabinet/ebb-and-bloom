import { create } from 'zustand';
import type { StateCreator } from 'zustand';
import { devtools } from 'zustand/middleware'; // Optional
import { init, snapCheck, updateBehavior, mutateWorld } from '@/game/core'; // Modular imports
import { Haptics } from '@capacitor/haptics';
import type { World } from 'bitecs';

interface GameState {
  world: World | null;
  pollution: number;
  behavior: { harmony: number; conquest: number; frolick: number };
  playerTraits: Record<string, number>;
  snapHistory: string[];
  demands: { ore: number; power: number; flow: number };
}

interface GameActions {
  initialize: () => void;
  performSnap: (aff1: number, aff2: number) => Promise<void>;
  addTrait: (name: string, cost: number) => void;
  loadGame: () => void;
  saveGame: () => void;
}

type GameStore = GameState & GameActions;

const createGameSlice: StateCreator<GameStore> = (set, get) => ({
  world: null,
  pollution: 0,
  behavior: { harmony: 0.3, conquest: 0.3, frolick: 0.4 },
  playerTraits: {},
  snapHistory: [],
  demands: { ore: 0, power: 0, flow: 0 },

  initialize: () => {
    set({ world: init() });
    get().loadGame(); // Hydrate from DB
  },

  performSnap: async (aff1: number, aff2: number) => {
    const { demands, behavior } = get();
    if (bitCount(aff1 & aff2) < 2) return;
    const newAff = combineResources(aff1, aff2, demands); // Your perm func
    get().snapHistory.push(`Snap: ${affMaskToName(aff1)} + ${affMaskToName(aff2)} → ${affMaskToName(newAff)}`);
    set((state) => ({ 
      pollution: state.pollution + 1 + (newAff & 64 ? 3 : 0),
      behavior: updateBehavior(state.behavior, 'conquest', 0.05) // Nudge
    }));
    snapCheck(get().world);
    await Haptics.impact({ style: 'light' });

    const { pollution } = get();
    if (pollution > 70) {
      mutateWorld(get().world);
      await Haptics.impact({ style: 'heavy' });
      set({ pollution: Math.max(0, pollution - 50) });
    }
  },

  addTrait: (name: string, cost: number) => {
    set((state) => {
      const traits = { ...state.playerTraits };
      traits[name] = (traits[name] || 0) + 1;
      const newDemands = {
        ore: (traits.chainsaw || 0) * 2,
        flow: (traits.flipper || 0) * 1,
        // Expand
      };
      return { playerTraits: traits, demands: newDemands };
    });
  },

  loadGame: () => {
    // DB pull → set()
    set({ pollution: 0 }); // Stub
  },

  saveGame: () => {
    // Serialize state to DB
    console.log('Saved:', get());
  },
});

// Utils (inline or export)
function bitCount(n: number) { return n.toString(2).match(/1/g)?.length || 0; }
function affMaskToName(mask: number) { return 'Resource'; /* Map */ }
function combineResources(aff1: number, aff2: number, demands: any) { return aff1 | aff2; }

export const useGame = create<GameStore>()(
  devtools((...a) => createGameSlice(...a), { name: 'EvoForge' })
);

// Selectors for perf (use in components)
export const usePollution = () => useGame((state) => state.pollution);
export const useMaxStyle = () => useGame((state) => 
  Object.entries(state.behavior).sort((a, b) => b[1] - a[1])[0][0]
);
export const useThemeClass = () => useGame((state) => {
  if (state.behavior.harmony > 0.6) return 'success';
  if (state.behavior.conquest > 0.6) return 'danger';
  return 'primary';
});
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { World } from 'bitecs'; // Assuming TS types from BitECS
import { init, snapCheck, updateBehavior, mutateWorld } from '@/game/core'; // Your modules
import { Haptics } from '@capacitor/haptics';

export const useGameStore = defineStore('game', () => {
  // Reactive State (proxies globals)
  const world = ref<World | null>(null);
  const pollution = ref(0);
  const behavior = ref({ harmony: 0.3, conquest: 0.3, frolick: 0.4 });
  const playerTraits = ref<Record<string, number>>({});
  const snapHistory = ref<string[]>([]); // e.g., ['Ore + Water → Alloy']
  const demands = ref({ ore: 0, power: 0, flow: 0 }); // From traits

  // Init Action: Boot world on app load
  const initialize = () => {
    world.value = init(); // BitECS spawn
    // Load from IndexedDB if saved
    loadGame();
  };

  // Getters: Computed smarts
  const maxStyle = computed(() => {
    const styles = Object.entries(behavior.value).sort((a, b) => b[1] - a[1]);
    return styles[0][0]; // 'conquest' etc.
  });

  const themeClass = computed(() => {
    if (behavior.value.harmony > 0.6) return 'success';
    if (behavior.value.conquest > 0.6) return 'danger';
    return 'primary';
  });

  const canSnap = (aff1: number, aff2: number) => {
    // From permutations.js
    return bitCount(aff1 & aff2) >= 2;
  };

  // Actions: Mutate state, trigger side effects
  const performSnap = async (aff1: number, aff2: number) => {
    if (!canSnap(aff1, aff2)) return;
    const newAff = combineResources(aff1, aff2, demands.value); // Your func
    snapHistory.value.push(`Snap: ${affMaskToName(aff1)} + ${affMaskToName(aff2)} → ${affMaskToName(newAff)}`);
    pollution.value += 1 + (newAff & 64 ? 3 : 0); // Void penalty
    updateBehavior(behavior.value, 'conquest', 0.05); // Nudge
    snapCheck(world.value); // ECS query
    await Haptics.impact({ style: 'light' }); // Mobile buzz

    if (pollution.value > 70) {
      mutateWorld(world.value); // Shock!
      await Haptics.impact({ style: 'heavy' });
      pollution.value = Math.max(0, pollution.value - 50);
    }
  };

  const addTrait = (name: string, cost: number) => {
    if (playerTraits.value[name]) playerTraits.value[name]++;
    else playerTraits.value[name] = 1;
    // Recalc demands
    demands.value.ore = (playerTraits.value.chainsaw || 0) * 2;
    demands.value.flow = (playerTraits.value.flipper || 0) * 1;
    // Redraw creature in creator
  };

  const loadGame = () => {
    // Stub: Pull from DB, hydrate refs
    pollution.value = 0; // Placeholder
  };

  const saveGame = () => {
    // Serialize to DB
    console.log('Saved:', { pollution: pollution.value, traits: playerTraits.value });
  };

  return {
    world, pollution, behavior, playerTraits, snapHistory, demands,
    initialize, performSnap, addTrait, loadGame, saveGame,
    maxStyle, themeClass, canSnap
  };
});

// Utils (export if needed)
function bitCount(n: number) { return n.toString(2).match(/1/g)?.length || 0; }
function affMaskToName(mask: number) { /* Map 1=ore etc. → 'Ore' */ return 'Resource'; }
function combineResources(aff1: number, aff2: number, demands: any) { /* From earlier */ return aff1 | aff2; }
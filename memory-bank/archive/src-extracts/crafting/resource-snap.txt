// Snippet 1 - Context: Balance: 70% snaps succeed (aff overlap), 20% mutate (noise), 10% fizzle (incompat, +tiny pollution). Keeps it rewarding, not grindy. #### Code Blueprint: Diff-Ready Expansion Building on `world.js` (post-modular). Add to `Resource` schema: `affinity: 'u32'`. New file: `permutations.js` for the engine.

// permutations.js - Import to world.js
const AFFINITIES = {
    heat: 1, flow: 2, bind: 4, power: 8, life: 16, metal: 32, void: 64, wild: 128
};
const BASE_RESOURCES = {
    ore: AFFINITIES.heat,
    water: AFFINITIES.flow,
    wood: AFFINITIES.bind,
    // ... expand to 10+
};

function generateAffinity(type) {
    return BASE_RESOURCES[type] || 0; // Procedural: + noise2D(typeSeed) * 256 for variants
}

function combineResources(aff1, aff2, demands = { ore: 0, power: 0 }) {
    const overlap = aff1 & aff2;
    if (bitCount(overlap) < 2) return 0; // No snap
    let newAff = aff1 | aff2;
    // Demand bias: If high oreDemand, +metal chance
    if (demands.ore > 5 && (newAff & AFFINITIES.heat)) {
        newAff |= AFFINITIES.metal;
    }
    // Noise twist
    const hash = noise.noise2D(aff1 + aff2 + Date.now() * 0.01, behavior.conquest);
    if (hash > 0.9) newAff |= AFFINITIES.wild; // Exotic
    if (behavior.conquest > 0.6) newAff |= AFFINITIES.void; // Risk
    return newAff;
}

function bitCount(n) { return n.toString(2).split('1').length - 1; } // Popcount stub

// In snapCheck() - world.js diff
function snapCheck() {
    // ... existing
    for (let a of adj) {
        const aff1 = Resource.affinity[id] || generateAffinity(Biome.type[id]); // Dynamic
        const aff2 = Resource.affinity[a] || generateAffinity(Biome.type[a]);
        const newAff = combineResources(aff1, aff2, playerDemands); // From Trait
        if (newAff) {
            const newId = bitecs.addEntity(world, [Position, Resource]);
            // ... pos
            Resource.affinity[newId] = newAff;
            Resource.type[newId] = hashToType(newAff); // Map to sprite/effect
            pollution += bitCount(newAff & AFFINITIES.void ? 3 : 1);
            // Chain spawn: Recurse shallow (depth<3)
            setTimeout(() => snapCheck(), 100); // Async for perf
        }
    }
}

// playerDemands getter in player.js
function getDemands() {
    return { ore: Trait.chainsaw[player] * 2, power: Trait.drill[player] || 0 /* expand */ };
}

// ---

// Snippet 2 - Context: 3. **Devtools**: Auto-wires Vue DevTools—inspect pollution like a boss. #### Core Game Store: `stores/game.ts` This bad boy centralizes everything: ECS globals → reactive state, actions for snaps/shocks, getters for UI smarts. Imports our modular `game.js` (core.js for BitECS init).

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { World } from 'bitecs'; // Assuming TS types from BitECS
import { init, snapCheck, updateBehavior, mutateWorld } from '@/game/core'; // Your modules
import { Haptics } from '@capacitor/haptics';

export const useGameStore = defineStore('game', () => {
  // Reactive State (proxies globals)
  const world = ref<World | null>(null);
  const pollution = ref(0);
  const behavior = ref({ harmony: 0.3, conquest: 0.3, frolick: 0.4 });
  const playerTraits = ref<Record<string, number>>({});
  const snapHistory = ref<string[]>([]); // e.g., ['Ore + Water → Alloy']
  const demands = ref({ ore: 0, power: 0, flow: 0 }); // From traits

  // Init Action: Boot world on app load
  const initialize = () => {
    world.value = init(); // BitECS spawn
    // Load from IndexedDB if saved
    loadGame();
  };

  // Getters: Computed smarts
  const maxStyle = computed(() => {
    const styles = Object.entries(behavior.value).sort((a, b) => b[1] - a[1]);
    return styles[0][0]; // 'conquest' etc.
  });

  const themeClass = computed(() => {
    if (behavior.value.harmony > 0.6) return 'success';
    if (behavior.value.conquest > 0.6) return 'danger';
    return 'primary';
  });

  const canSnap = (aff1: number, aff2: number) => {
    // From permutations.js
    return bitCount(aff1 & aff2) >= 2;
  };

  // Actions: Mutate state, trigger side effects
  const performSnap = async (aff1: number, aff2: number) => {
    if (!canSnap(aff1, aff2)) return;
    const newAff = combineResources(aff1, aff2, demands.value); // Your func
    snapHistory.value.push(`Snap: ${affMaskToName(aff1)} + ${affMaskToName(aff2)} → ${affMaskToName(newAff)}`);
    pollution.value += 1 + (newAff & 64 ? 3 : 0); // Void penalty
    updateBehavior(behavior.value, 'conquest', 0.05); // Nudge
    snapCheck(world.value); // ECS query
    await Haptics.impact({ style: 'light' }); // Mobile buzz

    if (pollution.value > 70) {
      mutateWorld(world.value); // Shock!
      await Haptics.impact({ style: 'heavy' });
      pollution.value = Math.max(0, pollution.value - 50);
    }
  };

  const addTrait = (name: string, cost: number) => {
    if (playerTraits.value[name]) playerTraits.value[name]++;
    else playerTraits.value[name] = 1;
    // Recalc demands
    demands.value.ore = (playerTraits.value.chainsaw || 0) * 2;
    demands.value.flow = (playerTraits.value.flipper || 0) * 1;
    // Redraw creature in creator
  };

  const loadGame = () => {
    // Stub: Pull from DB, hydrate refs
    pollution.value = 0; // Placeholder
  };

  const saveGame = () => {
    // Serialize to DB
    console.log('Saved:', { pollution: pollution.value, traits: playerTraits.value });
  };

  return {
    world, pollution, behavior, playerTraits, snapHistory, demands,
    initialize, performSnap, addTrait, loadGame, saveGame,
    maxStyle, themeClass, canSnap
  };
});

// Utils (export if needed)
function bitCount(n: number) { return n.toString(2).match(/1/g)?.length || 0; }
function affMaskToName(mask: number) { /* Map 1=ore etc. → 'Ore' */ return 'Resource'; }
function combineResources(aff1: number, aff2: number, demands: any) { /* From earlier */ return aff1 | aff2; }